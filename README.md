## Документация класса MazeGame

Структура класса:

**1. Константы:**

* `CELL_SIZE` (static final int): Определяет размер каждой клетки лабиринта в пикселях.

**2. Переменные экземпляра:**

* `rows` (int): Количество строк в лабиринте.
* `cols` (int): Количество столбцов в лабиринте.
* `maze` (int[][]): Двумерный целочисленный массив, представляющий структуру лабиринта. Каждое значение в массиве кодирует тип клетки:
    * `1`: Стена.
    * `0`: Путь (свободная клетка).
    * `-1`: Начальная точка.
    * `-2`: Конечная точка (выход).
* `start` (Point): Объект `Point`, хранящий координаты начальной точки лабиринта (строка, столбец).
* `exit` (Point): Объект `Point`, хранящий координаты конечной точки лабиринта (строка, столбец).
* `solutionPath` (List\<Point>): Список объектов `Point`, представляющий найденный путь от начальной до конечной точки.

**3. Конструктор:**

* `MazeGame(int rows, int cols)`:
    * Принимает желаемое количество строк и столбцов в качестве аргументов.
    * Проверяет, находятся ли заданные размеры в допустимом диапазоне (минимум 5, максимум 100). Если размеры некорректны, используются значения по умолчанию (50x50).
    * Устанавливает предпочтительный размер (`setPreferredSize`) для панели на основе размеров лабиринта и размера клетки.
    * Включает обработку фокуса (`setFocusable(true)`).
    * Инициализирует начальную точку (`start`) в фиксированном положении (1, 1).
    * Вызывает метод `findRandomExit()` для случайного определения положения конечной точки (`exit`).
    * Вызывает метод `generateMaze()` для создания случайного лабиринта.
    * Обозначает начальную и конечную точки в массиве `maze` специальными значениями (-1 и -2 соответственно).
    * Вызывает метод `findPath()` для поиска решения лабиринта.

**4. Методы:**

* `findRandomExit()` (private void):
    * Случайным образом выбирает одну из границ лабиринта (верхнюю, правую, нижнюю или левую).
    * Случайно определяет положение конечной точки (`exit`) на выбранной границе, отступая на одну клетку от угла.

* `generateMaze()` (private void):
    * Инициализирует двумерный массив `maze`, заполняя все клетки значением `1` (стена).
    * Вызывает рекурсивный метод `recursiveBacktracking()` для прокладки пути через лабиринт, начиная с точки (1, 1).
    * Гарантирует, что начальная и конечная точки являются частью пути (устанавливает значение `0`).
    * Вызывает метод `printMazeToConsole()` для вывода сгенерированного лабиринта в консоль (предназначено для отладки).

* `recursiveBacktracking(int r, int c)` (private void):
    * Рекурсивный алгоритм для генерации лабиринта методом обратного отслеживания.
    * Помечает текущую клетку как путь (`0`).
    * Случайно перемешивает порядок четырех возможных направлений движения (вверх, вниз, влево, вправо).
    * Для каждого направления проверяет, является ли соседняя клетка в пределах лабиринта и является ли она стеной.
    * Если соседняя клетка является стеной, "пробивает" стену между текущей и соседней клеткой, помечая промежуточную клетку как путь, и рекурсивно вызывает `recursiveBacktracking()` для соседней клетки.

* `findPath()` (private boolean):
    * Инициализирует пустой список `solutionPath` для хранения найденного пути.
    * Создает двумерный булев массив `visited` для отслеживания посещенных клеток во время поиска пути.
    * Вызывает рекурсивный метод `solveMazeRecursive()` для поиска пути от начальной точки.
    * Возвращает `true`, если путь найден, `false` в противном случае.

* `solveMazeRecursive(int r, int c, boolean[][] visited)` (private boolean):
    * Рекурсивный алгоритм для поиска пути в лабиринте.
    * Проверяет, является ли текущая клетка допустимой (в пределах лабиринта), не является ли она стеной (`1`) и не была ли она уже посещена.
    * Если клетка допустима и не является стеной, помечает ее как посещенную и добавляет в `solutionPath`.
    * Если текущая клетка является конечной точкой, возвращает `true` (путь найден).
    * Рекурсивно вызывает `solveMazeRecursive()` для всех четырех соседних клеток.
    * Если ни один из соседних путей не приводит к выходу, удаляет текущую клетку из `solutionPath` (обратное отслеживание) и возвращает `false`.

* `isValid(int r, int c)` (private boolean):
    * Проверяет, находятся ли заданные координаты (строка `r`, столбец `c`) в пределах границ лабиринта.

* `shuffleArray(int[][] array)` (private void):
    * Перемешивает строки двумерного целочисленного массива случайным образом (используется для случайного выбора направления в `recursiveBacktracking()`).

* `paintComponent(Graphics g)` (protected void):
    * Переопределенный метод `paintComponent` из класса `JPanel`, отвечающий за отрисовку лабиринта и найденного пути на экране.
    * Сначала вызывает `super.paintComponent(g)` для очистки предыдущего содержимого.
    * Перебирает все клетки массива `maze` и рисует прямоугольник соответствующего цвета в зависимости от типа клетки (стена - зеленый, путь - белый).
    * Рисует найденный путь коричневым цветом, если `solutionPath` не `null`.
    * Рисует начальную точку красным ромбом.
    * Рисует конечную точку желтым квадратом.

* `printMazeToConsole()` (private void):
    * Выводит текстовое представление сгенерированного лабиринта в консоль, используя '#' для стен, 'E' для выхода и пробелы для пути. Также выводит координаты старта и выхода. (Предназначено для отладки).

* `main(String[] args)` (public static void):
    * Главный метод приложения.
    * Запрашивает у пользователя размеры лабиринта (количество строк и столбцов) с проверкой на минимальные и максимальные значения и использованием значений по умолчанию в случае некорректного ввода.
    * Создает новый экземпляр класса `JFrame` с заголовком "Maze Solver".
    * Создает новый экземпляр класса `MazeGame` с заданными (или стандартными) размерами.
    * Добавляет объект `MazeGame` на фрейм.
    * Устанавливает операцию закрытия фрейма по умолчанию (`EXIT_ON_CLOSE`).
    * Упаковывает фрейм (`pack()`) для автоматического определения размеров.
    * Центрирует фрейм на экране (`setLocationRelativeTo(null)`).
    * Делает фрейм видимым (`setVisible(true)`).

**Использование:**

Для запуска игры необходимо скомпилировать и запустить файл `MazeGame.java`. При запуске программа предложит ввести размеры лабиринта. После ввода (или при использовании значений по умолчанию) будет сгенерирован и отображен лабиринт с выделенным путем решения.
